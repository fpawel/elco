{% package main %}

{% func (x *NotifyServicesSrc) Unit() %}
unit {%s x.unitName %};

interface
{%s uses(x.interfaceUses) %}
type
    {% for t,ht := range x.types %}{%s ht %} = reference to procedure (x:{%s t %});
    {% endfor %}

procedure HandleCopydata(var Message: TMessage);

{% for _,m := range x.services %}procedure SetOn{%s m.serviceName %}( AHandler : {%s m.handlerType %});
{% endfor %}

implementation 
{%s uses(x.implUses) %}

type
    TServerAppCmd = ({% for _,m := range x.services[:len(x.services)-1] %}Cmd{%s m.serviceName %}, {% endfor %}
    Cmd{%s x.services[len(x.services)-1].serviceName %});

var
    {% for _,m := range x.services %}_On{%s m.serviceName %} : {%s strEnsureFirstT(m.typeName) %}Handler;
    {% endfor %}

procedure HandleCopydata(var Message: TMessage);
var
    cd: PCOPYDATASTRUCT;
    cmd: TServerAppCmd;
    str:string;
begin
    cd := PCOPYDATASTRUCT(Message.LParam);
    cmd := TServerAppCmd(Message.WParam);
    Message.result := 1;
    SetString(str, PWideChar(cd.lpData), cd.cbData div 2);
    case cmd of
        {% for _,m := range x.services %}Cmd{%s m.serviceName %}:
        begin
            if not Assigned(_On{%s m.serviceName %}) then
                raise Exception.Create('_On{%s m.serviceName %} must be set');
            _On{%s m.serviceName %}({%s= m.instructionGetFromStr %});
        end;
        {% endfor %}
    else
        raise Exception.Create('wrong message: ' + IntToStr(Message.WParam));
    end;
end;

{% for _,m := range x.services %}procedure SetOn{%s m.serviceName %}( AHandler : {%s m.handlerType %});
begin
    if Assigned(_On{%s m.serviceName %}) then
        raise Exception.Create('_On{%s m.serviceName %} already set');
    _On{%s m.serviceName %} := AHandler;
end;
{% endfor %}

end.{% endfunc %}